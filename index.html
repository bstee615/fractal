<style>
html, body {
  width:  100%;
  height: 100%;
  margin: 0;
  overflow: hidden;
}
</style>

<canvas id="myCanvas" style="border: solid black 1px; padding: 0;">Your browser does not seem to support HTML5 canvas.</canvas>

<script>
var canvas = document.getElementById("myCanvas");
canvas.width  = window.innerWidth - 20;
canvas.height = window.innerHeight - 20;
canvas.style.margin = "9px";

class Point
{
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    static fromScreen(x, y) {
        return new Point(x - origin.x, y - origin.y).div(UNIT_POINT);
    }

    toScreen() {
        var t = this.times(UNIT_POINT);
        return new Point(t.x + origin.x, t.y + origin.y);
    }

    toOrigin() {
        var p = this.copy();
        copy.x += origin.x;
        copy.y += origin.y;
        return p;
    }

    toAbsolute() {
        var p = this.copy();
        copy.x -= origin.x;
        copy.y -= origin.y;
        return p;
    }

    copy() {
        return new Point(this.x, this.y);
    }

    plus(p) {
        return new Point(this.x + p.x, this.y + p.y);
    }

    minus(p) {
        return new Point(this.x - p.x, this.y - p.y);
    }

    timesComplex(p) {
        // (x + yi) (u + vi) = (xu - yv) + (xv + yu)i
        return new Point((this.x * p.x - this.y * p.y), (this.x * p.y + this.y * p.x));
    }

    times(p) {
        return new Point(this.x * p.x, this.y * p.y);
    }

    div(p) {
        return new Point(this.x / p.x, this.y / p.y);
    }
}

const UNIT = 200;
const UNIT_POINT = new Point(UNIT, UNIT);
const ZERO_POINT = new Point(0, 0);

var origin = new Point(canvas.width / 2, canvas.height / 2);
var C = ZERO_POINT.copy();

function toOrigin(x, y) {
    return originX + x, originY + y;
}

var ctx = canvas.getContext('2d');

function clearRect() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function lineToPoint(p) {
    p = p.toScreen();
    ctx.lineTo(p.x, p.y);
}

function fillCircleAtPoint(p, radius, color) {
    p = p.toScreen();
    ctx.beginPath();
    ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);
    var oldFillStyle = ctx.fillStyle;
    ctx.fillStyle = color;
    ctx.fill();
    ctx.fillStyle = oldFillStyle;
}

function strokeCircleAtPoint(p, radius, color) {
    p = p.toScreen();
    ctx.beginPath();
    ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);
    var oldStrokeStyle = ctx.strokeStyle;
    ctx.strokeStyle = color;
    ctx.stroke();
    ctx.strokeStyle = oldStrokeStyle;
}

var numLinks = 25;
const MAX_NUM_LINKS = 50;
var mouseLocation = null;

function doesItDiverge(p, C, depth) {
    var nextPoint = p;
    for (var i = 0; i < depth; i++) {
        nextPoint = nextPoint.timesComplex(nextPoint).plus(C);
        if (isNaN(nextPoint.x) || isNaN(nextPoint.y)) {
            return true;
        }
    }
    return false;
}

function drawMandelbrot(depth, stride, size) {
    for (var i = 0; i < canvas.width; i += stride) {
        for (var j = 0; j < canvas.height; j += stride) {
            var p = Point.fromScreen(i, j);
            if (doesItDiverge(ZERO_POINT, p, depth)) {
                fillCircleAtPoint(p, size, 'red');
            }
            else {
                fillCircleAtPoint(p, size, 'green');
            }
        }
    }
}

var timeouts = [];
function drawMandelbrotTimed(depth, stride, size) {
    var i = 0;
    function doit() {
        for (var j = 0; j < canvas.height; j += stride) {
            var p = Point.fromScreen(i, j);
            if (doesItDiverge(ZERO_POINT, p, depth)) {
                fillCircleAtPoint(p, size, 'red');
            }
            else {
                fillCircleAtPoint(p, size, 'green');
            }
        }
        i += stride;
        if (i >= canvas.width) {
            for (var t of timeouts) {
                clearInterval(t);
            }
            timeouts = [];
        }
    }
    timeouts.push(setInterval(doit, 10));
}

var stride = 25;
var size = 10;
var interactiveMode = true;
var drew = false;

function draw() {
    if (!interactiveMode) {
        if (!drew) {
            clearRect();
            drawMandelbrotTimed(250, 1, 1);
        }
        drew = true;
    }
    else {
        clearRect();

        if (mouseLocation == null) {
            return;
        }

        drawMandelbrot(numLinks, stride, size);

        var points = [mouseLocation];
        for (var i = 0; i < numLinks; i++) {
            mouseLocationPower = points[points.length-1].timesComplex(points[points.length-1]).plus(C);
            points.push(mouseLocationPower);
        }
        
        ctx.beginPath();
        var mouseLocationScreen = mouseLocation.toScreen();
        CScreen = C.toScreen();
        ctx.moveTo(CScreen.x, CScreen.y);
        for (var i = points.length-1; i >= 0; i --) {
            var p = points[i];
            lineToPoint(p);
        }
        lineToPoint(mouseLocation);
        ctx.stroke();

        var diverges = doesItDiverge(mouseLocation, C, numLinks);
        var color = null;
        if (diverges) {
            var color = 'red';
        }
        else {
            var color = 'green';
        }

        fillCircleAtPoint(C, 5, color);
        strokeCircleAtPoint(C, 5, 'black');
        for (var i = points.length-1; i >= 0; i --) {
            fillCircleAtPoint(points[i], 5, color);
            strokeCircleAtPoint(points[i], 5, 'black');
        }

        ctx.font = '48px serif';
        ctx.fillText('A', mouseLocationScreen.x, mouseLocationScreen.y);
        ctx.fillText('C', CScreen.x, CScreen.y);
        
        ctx.fillText(`${numLinks} links`, 350, 50);
        ctx.fillText(`interactive: ${interactiveMode}`, 25, 50);

        ctx.beginPath();
        ctx.arc(origin.x, origin.y, UNIT, 0, 2 * Math.PI);
        ctx.stroke();
    }
}

canvas.addEventListener('mousemove', e => {
    mouseLocation = Point.fromScreen(e.offsetX, e.offsetY);
    draw();
});

canvas.addEventListener("wheel", function (e) {
    var variation = parseInt(e.deltaY);
    if (variation < 0) {
        if (numLinks < MAX_NUM_LINKS) {
            numLinks ++;
        }
    }
    else {
        if (numLinks > 0) {
            numLinks --;
        }
    }
    draw();
});

window.addEventListener('keydown', function(e) {
    if (e.keyCode == '38') {
        C.y -= 1/UNIT*stride;
    }
    else if (e.keyCode == '40') {
        C.y += 1/UNIT*stride;
    }
    else if (e.keyCode == '37') {
        C.x -= 1/UNIT*stride;
    }
    else if (e.keyCode == '39') {
        C.x += 1/UNIT*stride;
    }
    else if (e.keyCode == '32') {
        interactiveMode = !interactiveMode;
        for (var t of timeouts) {
            clearInterval(t);
        }
        timeouts = [];
        drew = false;
    }
    draw();
})
</script>
