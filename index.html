<style>
html, body {
  width:  100%;
  height: 100%;
  margin: 0;
  overflow: hidden;
}
</style>

<canvas id="myCanvas" style="border: solid black 1px; padding: 0;">Your browser does not seem to support HTML5 canvas.</canvas>

<script>
var canvas = document.getElementById("myCanvas");
canvas.width  = window.innerWidth - 20;
canvas.height = window.innerHeight - 20;
canvas.style.margin = "9px";

class Point
{
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    static fromScreen(x, y) {
        return new Point(x - origin.x, y - origin.y).div(UNIT_POINT);
    }

    toScreen() {
        var t = this.times(UNIT_POINT);
        return new Point(t.x + origin.x, t.y + origin.y);
    }

    toOrigin() {
        var p = this.copy();
        copy.x += origin.x;
        copy.y += origin.y;
        return p;
    }

    toAbsolute() {
        var p = this.copy();
        copy.x -= origin.x;
        copy.y -= origin.y;
        return p;
    }

    copy() {
        return new Point(this.x, this.y);
    }

    plus(p) {
        return new Point(this.x + p.x, this.y + p.y);
    }

    minus(p) {
        return new Point(this.x - p.x, this.y - p.y);
    }

    timesComplex(p) {
        // (x + yi) (u + vi) = (xu - yv) + (xv + yu)i
        return new Point((this.x * p.x - this.y * p.y), (this.x * p.y + this.y * p.x));
    }

    times(p) {
        return new Point(this.x * p.x, this.y * p.y);
    }

    div(p) {
        return new Point(this.x / p.x, this.y / p.y);
    }
}

const UNIT = 200;
const UNIT_POINT = new Point(UNIT, UNIT);
const ZERO_POINT = new Point(0, 0);

var origin = new Point(canvas.width / 2, canvas.height / 2);
var C = ZERO_POINT.copy();

function toOrigin(x, y) {
    return originX + x, originY + y;
}

var ctx = canvas.getContext('2d');

function clearRect() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function lineToPoint(p) {
    p = p.toScreen();
    ctx.lineTo(p.x, p.y);
}

function fillCircleAtPoint(p, radius, color) {
    p = p.toScreen();
    ctx.beginPath();
    ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);
    var oldFillStyle = ctx.fillStyle;
    ctx.fillStyle = color;
    ctx.fill();
    ctx.fillStyle = oldFillStyle;
}

var numLinks = 5;
const MAX_NUM_LINKS = 50;
var mouseLocation = null;

function draw() {
    clearRect();

    if (mouseLocation == null) {
        return;
    }

    var points = [mouseLocation];
    for (var i = 0; i < numLinks; i++) {
        mouseLocationPower = points[points.length-1].timesComplex(points[points.length-1]).plus(C);
        points.push(mouseLocationPower);
    }
    
    ctx.beginPath();
    var mouseLocationScreen = mouseLocation.toScreen();
    CScreen = C.toScreen();
    ctx.moveTo(CScreen.x, CScreen.y);
    for (var i = points.length-1; i >= 0; i --) {
        var p = points[i];
        lineToPoint(p);
    }
    lineToPoint(mouseLocation);
    ctx.stroke();

    for (var i = points.length-1; i >= 0; i --) {
        fillCircleAtPoint(points[i], 5, 'red');
    }

    ctx.font = '48px serif';
    ctx.fillText('A', mouseLocationScreen.x, mouseLocationScreen.y);
    ctx.fillText('C', CScreen.x, CScreen.y);
    
    ctx.fillText(`${numLinks} links`, 30, 50);

    ctx.beginPath();
    ctx.arc(origin.x, origin.y, UNIT, 0, 2 * Math.PI);
    ctx.stroke();
}

canvas.addEventListener('mousemove', e => {
    mouseLocation = Point.fromScreen(e.offsetX, e.offsetY);
    draw();
});

canvas.addEventListener("wheel", function (e) {
    var variation = parseInt(e.deltaY);
    if (variation < 0) {
        if (numLinks < MAX_NUM_LINKS) {
            numLinks ++;
        }
    }
    else {
        if (numLinks > 0) {
            numLinks --;
        }
    }
    draw();
});

window.addEventListener('keydown', function(e) {
    if (e.keyCode == '38') {
        C.y -= 0.05;
    }
    else if (e.keyCode == '40') {
        C.y += 0.05;
    }
    else if (e.keyCode == '37') {
        C.x -= 0.05;
    }
    else if (e.keyCode == '39') {
        C.x += 0.05;
    }
    draw();
})
</script>
